---
title: java多线程相关总结
date: 2016-11-19 22:32:30
tags:
- java
- work
---
在工作中使用java或多或少都会接触一些和多线程相关的代码，在很多的业务场景中都需要使用多线程，虽然在工作中使用的多线程相关知识并不是很多，但还是想学习了解一下多线程是如何实现的。
<!--more-->

# 一：Synchronized实现
Synchronized作用于方法和代码块时，锁的是对象。当锁的是静态方法时，锁的是类。那么，synchronize是如何实现多个线程同时访问一个共享资源时对资源加锁。
过程：
1.当有多个线程同时请求某个被加上锁的资源时，首先会将线程放入到Contention List竞争队列，Contention List新进来的线程放在队的队头。
2.在Contention List中符合被调用要求的线程会被放入Entry List队列中，Entry List会并发访问Contention List，在Contention List的队尾取出线程放入Entry List，Entry List的很重要的作用是为了缓解对Contention List队尾的征用。
3.在Entry List队列中会选取一个线程作为OnDeck（也就是线程处于就绪状态），一般是取队头的线程。
4.当锁被释放后，OnDeck被调用去竞争锁，获得锁的线程被称为Owner（也就是运行时状态），没有获得到锁的线程回继续回到Entry List，依然在队头。
5.当Owner释放锁之后，如果发现EntryList为空，则从Contention List取出线程到Entry List中。如果OnDeck被wait方法阻塞则放入WaitSet，当被notify/notifyAll唤醒后进入Entry List继续等待调度。
Synchronizzed就是利用这种机制实现多线程的请求加锁机制。

状态转换关系：
<img src="/img/synchronizzed的状态转换关系.png" >

# 二：优化策略
## 自旋锁：
那些处于ContetionList、EntryList、WaitSet中的线程均处于阻塞状态，阻塞操作由操作系统完成。线程被阻塞后便进入内核调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响 锁的性能。
解决：
缓解上述问题的办法便是自旋，若Owner线程能在很短的时间内释放锁，则那些正在争用线程可以稍微等一等（自旋），这个过程线程什么也不做，可以是几次空的for询，目的是占用cup，暂时不放开。 在Owner线程释放锁后，争用线程可能会立即得到锁，从而避免了系统阻塞。争用线程自旋一段时间后还是无法 获得锁，这时争用线程则会停止自旋进入阻塞状态。
## 偏向锁
每次线程枷加锁解锁都会涉及到一些CAS原子操作，CAS操作会延迟本地调用，因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个 线程，之后的多次调用则可以避免CAS操作，说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。


# 三：Volatile
Volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。它在某些情况下比synchronized的开销更小。
实现：Volatile保证每次新值能立即同步到主内存,以及每次使用前立即从主内存刷新

每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，对于volatile修饰的变量，jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的，所以volatile并不能保证操作的原子性。
